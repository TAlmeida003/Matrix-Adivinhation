Index: FilePy/HiddenSums/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy.Board import Board\r\nfrom ArquivosPy.Player import Player\r\nfrom ArquivosPy.RevealedElement import RevealedElement\r\nfrom ArquivosPy import ScreenPrints\r\n\r\n\r\nclass HiddenSums:\r\n    def __init__(self, number_of_rounds: int, number_of_board: int, level: str) -> None:\r\n\r\n        self.__level__: str = level\r\n        self.__number_of_rounds__: int = number_of_rounds\r\n        self.__number_of_board__ = number_of_board\r\n        self.__number_current_of_rounds__: int = 1\r\n\r\n        board_player_1, board_player_2 = self.create_player()\r\n        self.__player_one__: Player = Player(\"Jogador Nº1\", board_player_1, ScreenPrints.get_paint_color(\"YELLOW\"))\r\n        self.__player_two__: Player = Player(\"Jogador Nº2\", board_player_2, ScreenPrints.get_paint_color(\"RED\"))\r\n        self.__current_player__: Player = self.__player_one__\r\n\r\n    def create_player(self) -> tuple[Board, Board]:\r\n        if self.__number_of_board__ == 1:\r\n            board_player: Board = Board(self.__level__)\r\n            return board_player, board_player\r\n\r\n        board_player_1: Board = Board(self.__level__)\r\n        board_player_2: Board = Board(self.__level__)\r\n        return board_player_1, board_player_2\r\n\r\n    def add_history_player(self) -> None:\r\n        self.__player_one__.add_history()\r\n        self.__player_two__.add_history()\r\n\r\n    def is_number_matches_are_over(self) -> bool:\r\n        return self.__number_current_of_rounds__ > self.__number_of_rounds__\r\n\r\n    def is_coordinate_complete(self, coordinate: tuple[str, int]) -> bool:\r\n        return self.__current_player__.get_board().is_coordinate_complete(coordinate)\r\n\r\n    def to_score(self) -> None:\r\n        GUSS_PLAYER_ONE: int = self.__player_one__.get_difference_of_guess_to_sum()\r\n        GUSS_PLAYER_TWO: int = self.__player_two__.get_difference_of_guess_to_sum()\r\n\r\n        if GUSS_PLAYER_ONE < GUSS_PLAYER_TWO:\r\n            self.__player_one__.count_points()\r\n        elif GUSS_PLAYER_ONE > GUSS_PLAYER_TWO:\r\n            self.__player_two__.count_points()\r\n        else:\r\n            self.__player_one__.count_points()\r\n            self.__player_two__.count_points()\r\n\r\n    def get_current_player(self) -> Player:\r\n        return self.__current_player__\r\n\r\n    def add_guess(self, coordinate: tuple[str, int]) -> None:\r\n        self.__current_player__.set_current_guess(coordinate)\r\n\r\n    def next_player(self) -> None:\r\n        if self.__current_player__ is self.__player_one__:\r\n            self.__current_player__ = self.__player_two__\r\n        else:\r\n            self.__current_player__ = self.__player_one__\r\n\r\n    def reveal_winner_coordinates(self) -> None:\r\n        GUSS_PLAYER_ONE: int = self.__player_one__.get_difference_of_guess_to_sum()\r\n        GUSS_PLAYER_TWO: int = self.__player_two__.get_difference_of_guess_to_sum()\r\n\r\n        if GUSS_PLAYER_ONE < GUSS_PLAYER_TWO:\r\n            list_elements: list[RevealedElement] = self.__player_one__.reveal_house()\r\n            self.__player_one__.get_board().add_relevant_elements(list_elements)\r\n        elif GUSS_PLAYER_ONE > GUSS_PLAYER_TWO:\r\n            list_elements: list[RevealedElement] = self.__player_two__.reveal_house()\r\n            self.__player_two__.get_board().add_relevant_elements(list_elements)\r\n        else:\r\n            list_elements_one: list[RevealedElement] = self.__player_one__.reveal_house()\r\n            list_elements_two: list[RevealedElement] = self.__player_two__.reveal_house()\r\n            self.reveal_tie(list_elements_one, list_elements_two)\r\n\r\n    def reveal_tie(self, list_elements_one: list[RevealedElement], list_elements_two: list[RevealedElement]) -> None:\r\n        if self.__number_of_board__ == 1:\r\n            self.join_list(list_elements_one, list_elements_two)\r\n        else:\r\n            self.__player_one__.get_board().add_relevant_elements(list_elements_one)\r\n            self.__player_two__.get_board().add_relevant_elements(list_elements_two)\r\n\r\n    def join_list(self, list_elements_one: list[RevealedElement], list_elements_two: list[RevealedElement]) -> None:\r\n        for element in list_elements_one:\r\n            if not element.in_list(list_elements_two):\r\n                list_elements_two.append(element)\r\n            else:\r\n                INDEX: int = element.index_list(list_elements_two)\r\n                list_elements_two[INDEX].set_color(\"\\033[1;97m\")\r\n        self.__player_one__.get_board().add_relevant_elements(list_elements_two)\r\n\r\n    def next_round(self) -> None:\r\n        self.__number_current_of_rounds__ += 1\r\n\r\n    def get_player_one(self) -> Player:\r\n        return self.__player_one__\r\n\r\n    def get_player_two(self) -> Player:\r\n        return self.__player_two__\r\n\r\n    def is_board_complete(self) -> bool:\r\n        IS_BOARD_COMPLETE_PLAYER_ONE: bool = self.__player_one__.get_board().is_board_complete()\r\n        IS_BOARD_COMPLETE_PLAYER_TWO: bool = self.__player_two__.get_board().is_board_complete()\r\n\r\n        return IS_BOARD_COMPLETE_PLAYER_ONE or IS_BOARD_COMPLETE_PLAYER_TWO\r\n\r\n    def get_level(self) -> str:\r\n        return self.__level__\r\n\r\n    def get_current_round(self) -> int:\r\n        return self.__number_current_of_rounds__\r\n\r\n    def decide_winner(self) -> str:\r\n        if self.__player_one__.get_punctuation() > self.__player_two__.get_punctuation():\r\n            return \"Vencedor\" + self.__player_one__.get_name()\r\n        elif self.__player_one__.get_punctuation() < self.__player_two__.get_punctuation():\r\n            return \"Vencedor\" + self.__player_two__.get_name()\r\n\r\n        return \"Empate\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/HiddenSums/__init__.py b/FilePy/HiddenSums/__init__.py
--- a/FilePy/HiddenSums/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/HiddenSums/__init__.py	(date 1696698082519)
@@ -1,7 +1,7 @@
-from ArquivosPy.Board import Board
-from ArquivosPy.Player import Player
-from ArquivosPy.RevealedElement import RevealedElement
-from ArquivosPy import ScreenPrints
+from FilePy.Board import Board
+from FilePy.Player import Player
+from FilePy.RevealedElement import RevealedElement
+from FilePy import ScreenPrints
 
 
 class HiddenSums:
Index: FilePy/Board/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nfrom ArquivosPy.RevealedElement import RevealedElement\r\n\r\n\r\nclass Board:\r\n    \"\"\"\r\n    Classe que representa um tabuleiro para o jogo das somas escondidas.\r\n\r\n    Atributos:\r\n        __level__ (str): O nível de dificuldade do tabuleiro.\r\n        __array_int__ (list[list[int]]): Uma matriz 2D contendo valores inteiros.\r\n        __revealed_int_array__ (list[list[RevealedElement]]): Uma matriz 2D contendo objetos RevealedElement.\r\n        LIMIT_DICT (dict[str, int]): Um dicionário que mapeia os níveis de dificuldade para limites de números aleatórios.\r\n        SIZE_DICT (dict[str, int]): Um dicionário que mapeia os níveis de dificuldade para tamanhos de tabuleiro.\r\n        SIZE (int): O tamanho do tabuleiro.\r\n    \"\"\"\r\n\r\n    def __init__(self, level: str) -> None:\r\n        \"\"\"\r\n        Inicializa uma instância de Board com o nível de dificuldade especificado.\r\n\r\n        Args:\r\n           level (str): O nível de dificuldade (por exemplo, \"FÁCIL\", \"MÉDIO\", \"DIFÍCIL\").\r\n        \"\"\"\r\n        self.__level__: str = level\r\n        self.__array_int__: list[list[int]] = []\r\n        self.__revealed_int_array__: list[list[RevealedElement]] = []\r\n\r\n        self.LIMIT_DICT: dict[str, int] = {\"EASY\": 30, \"AVERAGE\": 60, \"DIFFICULT\": 100}\r\n        self.SIZE_DICT: dict[str, int] = {\"EASY\": 3, \"AVERAGE\": 4, \"DIFFICULT\": 5}\r\n        self.SIZE: int = self.SIZE_DICT[self.__level__]\r\n\r\n        self.create_board()\r\n        self.add_tuple_board()\r\n\r\n    def create_board(self) -> None:\r\n        \"\"\"\r\n        Cria o tabuleiro do jogo inicializando e preenchendo matrizes.\r\n        \"\"\"\r\n        self.create_array()\r\n        self.add_number_board()\r\n        self.add_sum_line()\r\n        self.add_sum_columns()\r\n\r\n    def create_array(self) -> None:\r\n        SIZE_ARRAY: int = 6\r\n\r\n        for i in range(SIZE_ARRAY):\r\n            line: list[int] = []\r\n            for j in range(SIZE_ARRAY):\r\n                line.append(0)\r\n            self.__array_int__.append(line)\r\n\r\n    def add_number_board(self) -> None:\r\n        for i in range(self.SIZE):\r\n            for j in range(self.SIZE):\r\n                self.__array_int__[i][j] = self.get_random_number()\r\n\r\n    def get_random_number(self) -> int:\r\n        random_number: int = random.randint(1, self.LIMIT_DICT[self.__level__])\r\n\r\n        while not self.is_valid_random_number(random_number):\r\n            random_number: int = random.randint(1, self.LIMIT_DICT[self.__level__])\r\n\r\n        return random_number\r\n\r\n    def is_valid_random_number(self, random_number: int):\r\n        for i in range(self.SIZE):\r\n            if random_number in self.__array_int__[i]:\r\n                return False\r\n\r\n        return True\r\n\r\n    def add_sum_line(self) -> None:\r\n        for i in range(self.SIZE):\r\n            sum_line: int = 0\r\n            for j in range(self.SIZE):\r\n                sum_line += self.__array_int__[i][j]\r\n            self.__array_int__[i][self.SIZE] = sum_line\r\n\r\n    def add_sum_columns(self) -> None:\r\n        for i in range(self.SIZE):\r\n            sum_column: int = 0\r\n            for j in range(self.SIZE):\r\n                sum_column += self.__array_int__[j][i]\r\n            self.__array_int__[self.SIZE][i] = sum_column\r\n\r\n    def add_tuple_board(self) -> None:\r\n        SIZE_ARRAY: int = 6\r\n\r\n        for i in range(SIZE_ARRAY):\r\n            line: list[RevealedElement] = []\r\n            for j in range(SIZE_ARRAY):\r\n                line.append(RevealedElement(0))\r\n            self.__revealed_int_array__.append(line)\r\n\r\n    def add_relevant_elements(self, list_to_reveal: list[RevealedElement]) -> None:\r\n        for relieved_element in list_to_reveal:\r\n            for i in range(self.SIZE):\r\n                for j in range(self.SIZE):\r\n                    if relieved_element.get_number() == self.__array_int__[i][j]:\r\n                        self.__revealed_int_array__[i][j] = relieved_element\r\n\r\n        self.add_relevant_sum()\r\n\r\n    def add_relevant_sum(self) -> None:\r\n        for i in range(self.SIZE):\r\n            if self.is_coordinate_complete((f\"L{i}\", 0)):\r\n                self.__revealed_int_array__[i][self.SIZE] = RevealedElement(self.__array_int__[i][self.SIZE],\r\n                                                                            \"\\033[1;34m\")\r\n        for i in range(self.SIZE):\r\n            if self.is_coordinate_complete((f\"C{i}\", 0)):\r\n                self.__revealed_int_array__[self.SIZE][i] = RevealedElement(self.__array_int__[self.SIZE][i],\r\n                                                                            \"\\033[1;34m\")\r\n\r\n    def count_revealed_houses(self, coordinate: tuple[str, int]) -> int:\r\n        number_of_point: int = 0\r\n\r\n        for i in range(self.SIZE):\r\n            if coordinate[0][0] == \"L\" and not self.is_revealed_house(int(coordinate[0][1]), i):\r\n                number_of_point += 1\r\n            elif coordinate[0][0] == \"C\" and not self.is_revealed_house(i, int(coordinate[0][1])):\r\n                number_of_point += 1\r\n\r\n        return number_of_point\r\n\r\n    def is_revealed_house(self, line: int, columns: int) -> bool:\r\n        return self.__array_int__[line][columns] == self.__revealed_int_array__[line][columns].get_number()\r\n\r\n    def is_board_complete(self) -> bool:\r\n        for i in range(self.SIZE):\r\n            for j in range(self.SIZE):\r\n                if not self.is_revealed_house(i, j):\r\n                    return False\r\n\r\n        return True\r\n\r\n    def is_coordinate_complete(self, coordinate: tuple[str, int]) -> bool:\r\n        INDEX_COORD: int = int(coordinate[0][1])\r\n\r\n        for i in range(self.SIZE):\r\n            if coordinate[0][0] == \"L\" and not self.is_revealed_house(INDEX_COORD, i):\r\n                return False\r\n            elif coordinate[0][0] == \"C\" and not self.is_revealed_house(i, INDEX_COORD):\r\n                return False\r\n\r\n        return True\r\n\r\n    def get_array_int(self) -> list[list[int]]:\r\n        return self.__array_int__\r\n\r\n    def get_revealed_int_array(self) -> list[list[RevealedElement]]:\r\n        return self.__revealed_int_array__\r\n\r\n    def get_reveal_max(self, coordinate: tuple[str, int], color: str) -> list[RevealedElement]:\r\n        number_max: int = 0\r\n        INDEX_COORD: int = int(coordinate[0][1])\r\n\r\n        for i in range(self.SIZE):\r\n            if coordinate[0][0] == \"L\" and not self.is_revealed_house(INDEX_COORD, i):\r\n                if number_max < self.__array_int__[INDEX_COORD][i]:\r\n                    number_max = self.__array_int__[INDEX_COORD][i]\r\n            elif coordinate[0][0] == \"C\" and not self.is_revealed_house(i, INDEX_COORD):\r\n                if number_max < self.__array_int__[i][INDEX_COORD]:\r\n                    number_max = self.__array_int__[i][INDEX_COORD]\r\n\r\n        return list([RevealedElement(number_max, color)])\r\n\r\n    def get_reveal_min(self, coordinate: tuple[str, int], color: str) -> list[RevealedElement]:\r\n        INDEX_COORD: int = int(coordinate[0][1])\r\n        number_min: int = self.LIMIT_DICT[self.__level__] + 1\r\n\r\n        for i in range(self.SIZE):\r\n            if coordinate[0][0] == \"L\" and not self.is_revealed_house(INDEX_COORD, i):\r\n                if number_min > self.__array_int__[INDEX_COORD][i]:\r\n                    number_min = self.__array_int__[INDEX_COORD][i]\r\n            elif coordinate[0][0] == \"C\" and not self.is_revealed_house(i, INDEX_COORD):\r\n                if number_min > self.__array_int__[i][INDEX_COORD]:\r\n                    number_min = self.__array_int__[i][INDEX_COORD]\r\n\r\n        return list([RevealedElement(number_min, color)])\r\n\r\n    def get_reveal_all(self, coordinate: tuple[str, int], color: str) -> list[RevealedElement]:\r\n        list_elements: list[RevealedElement] = []\r\n        INDEX_COORD: int = int(coordinate[0][1])\r\n\r\n        for i in range(self.SIZE):\r\n            if coordinate[0][0] == \"L\" and not self.is_revealed_house(INDEX_COORD, i):\r\n                list_elements.append(RevealedElement(self.__array_int__[INDEX_COORD][i], color))\r\n            elif coordinate[0][0] == \"C\" and not self.is_revealed_house(i, INDEX_COORD):\r\n                list_elements.append(RevealedElement(self.__array_int__[i][INDEX_COORD], color))\r\n\r\n        return list_elements\r\n\r\n    def get_sum_of_coordinate(self, coordinate: tuple[str, int]) -> int:\r\n        if coordinate[0][0] == \"L\":\r\n            return self.__array_int__[int(coordinate[0][1])][self.SIZE]\r\n\r\n        return self.__array_int__[self.SIZE][int(coordinate[0][1])]\r\n\r\n    def __repr__(self) -> str:\r\n        return str(self.__dict__)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Board/__init__.py b/FilePy/Board/__init__.py
--- a/FilePy/Board/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Board/__init__.py	(date 1696698082583)
@@ -1,5 +1,5 @@
 import random
-from ArquivosPy.RevealedElement import RevealedElement
+from FilePy.RevealedElement import RevealedElement
 
 
 class Board:
Index: FilePy/Game/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy.HiddenSums import HiddenSums\r\nfrom ArquivosPy.Inputs import LevelMenu, BoardNumberMenu, NumberOfRoundsMenu, PlayerMovement\r\nfrom ArquivosPy import ScreenPrints\r\n\r\n\r\ndef player_movement(hiddenSums: HiddenSums) -> None:\r\n    coordinates: str\r\n    guess: int\r\n\r\n    coordinates, guess = PlayerMovement.inicialize(hiddenSums)\r\n    hiddenSums.add_guess((coordinates, guess))\r\n    hiddenSums.next_player()\r\n\r\n\r\ndef register_settings() -> HiddenSums:\r\n    level: str = LevelMenu.inicialize()\r\n    number_of_board: int = BoardNumberMenu.inicialize()\r\n    number_of_rounds: int = NumberOfRoundsMenu.inicialize(level)\r\n\r\n    return HiddenSums(number_of_rounds, number_of_board, level)\r\n\r\n\r\ndef decide_winner(hiddenSums: HiddenSums) -> None:\r\n    ScreenPrints.display_winner(hiddenSums)\r\n\r\n\r\ndef inicialize() -> None:\r\n    hiddenSums: HiddenSums = register_settings()\r\n\r\n    while not hiddenSums.is_number_matches_are_over() and not hiddenSums.is_board_complete():\r\n        player_movement(hiddenSums)\r\n        player_movement(hiddenSums)\r\n\r\n        hiddenSums.add_history_player()\r\n        hiddenSums.to_score()\r\n        hiddenSums.reveal_winner_coordinates()\r\n        hiddenSums.next_round()\r\n\r\n    decide_winner(hiddenSums)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Game/__init__.py b/FilePy/Game/__init__.py
--- a/FilePy/Game/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Game/__init__.py	(date 1696698082401)
@@ -1,6 +1,6 @@
-from ArquivosPy.HiddenSums import HiddenSums
-from ArquivosPy.Inputs import LevelMenu, BoardNumberMenu, NumberOfRoundsMenu, PlayerMovement
-from ArquivosPy import ScreenPrints
+from FilePy.HiddenSums import HiddenSums
+from FilePy.Inputs import LevelMenu, BoardNumberMenu, NumberOfRoundsMenu, PlayerMovement
+from FilePy import ScreenPrints
 
 
 def player_movement(hiddenSums: HiddenSums) -> None:
Index: FilePy/Inputs/NumberOfRoundsMenu/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy import ScreenPrints\r\n\r\n\r\ndef check_option(number_of_round: int, level: str) -> None:\r\n    rounds_by_level_dict: dict[str, int] = {\"EASY\": 9, \"AVERAGE\": 16, \"DIFFICULT\": 25}\r\n\r\n    if number_of_round < 1:\r\n        raise RuntimeError(\"O número de rodadas informado é invalido\")\r\n    elif number_of_round > rounds_by_level_dict[level]:\r\n        raise RuntimeError(f\"O número de rodadas informado é maior que o limite do nível de \"\r\n                           f\"{rounds_by_level_dict[level]}\")\r\n    elif number_of_round % 2 == 0:\r\n        raise RuntimeError(\"O número de rodadas informado não pode ser par\")\r\n\r\n\r\ndef is_valid_option_two(number_of_round: int, level: str) -> bool:\r\n    try:\r\n        check_option(number_of_round, level)\r\n        return True\r\n    except RuntimeError as error:\r\n        ScreenPrints.get_report_error(error.__str__())\r\n        return False\r\n\r\n\r\ndef check_number_of_rounds(user_choice: int) -> None:\r\n    set_options: set[int] = {1, 2}\r\n\r\n    if user_choice not in set_options:\r\n        raise RuntimeError(\"A maneira de finalizar o jogo informada não existe\")\r\n\r\n\r\ndef is_valid_number_of_rounds(user_choice: int) -> bool:\r\n    try:\r\n        check_number_of_rounds(user_choice)\r\n        return True\r\n    except RuntimeError as error:\r\n        ScreenPrints.get_report_error(error.__str__())\r\n        return False\r\n\r\n\r\ndef input_option_two() -> int:\r\n    try:\r\n        print(\" \" * 49, end=\"* \")\r\n        user_choice: int = int(input(\"INFORME O NÚMERO DE RODADAS DESEJADA: \"))\r\n        ScreenPrints.get_clear_prompt()\r\n        return user_choice\r\n    except ValueError:\r\n        ScreenPrints.get_clear_prompt()\r\n        return -1\r\n\r\n\r\ndef define_number_of_rounds(user_choice: int) -> int:\r\n    OPTION_TWO: int = 2\r\n    NUMBER_OF_COMPLETED_GAMES: int = 9\r\n\r\n    if user_choice == OPTION_TWO:\r\n        return input_option_two()\r\n\r\n    return NUMBER_OF_COMPLETED_GAMES\r\n\r\n\r\ndef display_option_rounds() -> None:\r\n    ScreenPrints.get_display_option(\"WHITE\", \"1\", \"COMPLETA TABULEIRO\")\r\n    ScreenPrints.get_display_option(\"BLUE\", \"2\", \"DEFINIR NÚMERO DE RODADAS\")\r\n\r\n\r\ndef display_rounds() -> None:\r\n    ScreenPrints.display_header(\"CRIAR TABULEIRO\")\r\n\r\n    print(\"\\n\" * 2, \"NÚMERO DE RODADAS:\".center(170))\r\n\r\n    display_option_rounds()\r\n    ScreenPrints.get_baseboard()\r\n    print(\" \" * 50, end=\"* \")\r\n\r\n\r\ndef input_number_of_rounds() -> int:\r\n    try:\r\n        display_rounds()\r\n        user_choice: int = int(input(\"INFORME QUAL A OPÇÃO DESEJADA: \"))\r\n        ScreenPrints.get_clear_prompt()\r\n        return user_choice\r\n    except ValueError:\r\n        ScreenPrints.get_clear_prompt()\r\n        return -1\r\n\r\n\r\ndef inicialize(level: str) -> int:\r\n    user_choice: int = input_number_of_rounds()\r\n    number_of_round: int = define_number_of_rounds(user_choice)\r\n\r\n    while not (is_valid_number_of_rounds(user_choice) and is_valid_option_two(number_of_round, level)):\r\n        user_choice = input_number_of_rounds()\r\n        number_of_round = define_number_of_rounds(user_choice)\r\n\r\n    return number_of_round\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Inputs/NumberOfRoundsMenu/__init__.py b/FilePy/Inputs/NumberOfRoundsMenu/__init__.py
--- a/FilePy/Inputs/NumberOfRoundsMenu/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Inputs/NumberOfRoundsMenu/__init__.py	(date 1696698082376)
@@ -1,4 +1,4 @@
-from ArquivosPy import ScreenPrints
+from FilePy import ScreenPrints
 
 
 def check_option(number_of_round: int, level: str) -> None:
Index: FilePy/Inputs/LevelMenu/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy import ScreenPrints\r\n\r\n\r\ndef convert_option_in_level(user_choice: str) -> str:\r\n    list_level: list[str] = [\"EASY\", \"AVERAGE\", \"DIFFICULT\"]\r\n    return list_level[int(user_choice) - 1]\r\n\r\n\r\ndef check_level(user_choice: str) -> None:\r\n    set_option: set[str] = {\"1\", \"2\", \"3\"}\r\n\r\n    if user_choice not in set_option:\r\n        raise RuntimeError(\"O NÍVEL INFORMADO NÃO ESTÁ DISPONÍVEL\")\r\n\r\n\r\ndef is_valid_level(user_choice: str) -> bool:\r\n    try:\r\n        check_level(user_choice)\r\n        return True\r\n    except RuntimeError as error:\r\n        ScreenPrints.get_report_error(error.__str__())\r\n        return False\r\n\r\n\r\ndef display_option_level() -> None:\r\n    ScreenPrints.get_display_option(\"WHITE\", \"1\", \"FÁCIL - TABULEIRO 3 X 3\")\r\n    ScreenPrints.get_display_option(\"BLUE\", \"2\", \"MÉDIO - TABULEIRO 4 X 4\")\r\n    ScreenPrints.get_display_option(\"WHITE\", \"3\", \"DIFÍCIL - TABULEIRO 5 X 5\")\r\n\r\n\r\ndef display_level() -> None:\r\n    ScreenPrints.display_header(\"CRIAR TABULEIRO\")\r\n\r\n    print(\"\\n\\n\", \"NÍVEIS DE TABULEIRO:\".center(170))\r\n\r\n    display_option_level()\r\n    ScreenPrints.get_baseboard()\r\n    print(\" \" * 50, end=\"* \")\r\n\r\n\r\ndef input_level() -> str:\r\n    display_level()\r\n    user_choice: str = input(\"INFORME QUAL A OPÇÃO DESEJADA: \")\r\n    ScreenPrints.get_clear_prompt()\r\n\r\n    return user_choice\r\n\r\n\r\ndef inicialize() -> str:\r\n    user_choice: str = input_level()\r\n\r\n    while not is_valid_level(user_choice):\r\n        user_choice = input_level()\r\n\r\n    return convert_option_in_level(user_choice)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Inputs/LevelMenu/__init__.py b/FilePy/Inputs/LevelMenu/__init__.py
--- a/FilePy/Inputs/LevelMenu/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Inputs/LevelMenu/__init__.py	(date 1696698082425)
@@ -1,4 +1,4 @@
-from ArquivosPy import ScreenPrints
+from FilePy import ScreenPrints
 
 
 def convert_option_in_level(user_choice: str) -> str:
Index: FilePy/Inputs/BoardNumberMenu/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy import ScreenPrints\r\n\r\n\r\ndef check_board_number(user_choice: int) -> None:\r\n    set_option: set[int] = {1, 2}\r\n\r\n    if user_choice not in set_option:\r\n        raise RuntimeError(\"O tabuleiro informado não está disponível\")\r\n\r\n\r\ndef is_valid_board_number(use_choice: int) -> bool:\r\n    try:\r\n        check_board_number(use_choice)\r\n        return True\r\n    except RuntimeError as error:\r\n        ScreenPrints.get_report_error(error.__str__())\r\n        return False\r\n\r\n\r\ndef display_option_board_number() -> None:\r\n    ScreenPrints.get_display_option(\"WHITE\", \"1\", \"1 Tabuleiro\")\r\n    ScreenPrints.get_display_option(\"BLUE\", \"2\", \"2 Tabuleiros\")\r\n\r\n\r\ndef display_board_number() -> None:\r\n    ScreenPrints.display_header(\"CRIAR TABULEIRO\")\r\n\r\n    print(\"\\n\\n\", \"TABULEIROS DISPONÍVEIS:\".center(170))\r\n\r\n    display_option_board_number()\r\n    ScreenPrints.get_baseboard()\r\n    print(\" \" * 50, end=\"* \")\r\n\r\n\r\ndef input_board_number() -> int:\r\n    try:\r\n        display_board_number()\r\n        user_choice: int = int(input(\"INFORME QUAL A OPÇÃO DESEJADA: \"))\r\n        ScreenPrints.get_clear_prompt()\r\n        return user_choice\r\n    except ValueError:\r\n        return -1\r\n\r\n\r\ndef inicialize() -> int:\r\n    user_choice: int = input_board_number()\r\n\r\n    while not is_valid_board_number(user_choice):\r\n        user_choice = input_board_number()\r\n\r\n    return user_choice\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Inputs/BoardNumberMenu/__init__.py b/FilePy/Inputs/BoardNumberMenu/__init__.py
--- a/FilePy/Inputs/BoardNumberMenu/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Inputs/BoardNumberMenu/__init__.py	(date 1696698082496)
@@ -1,4 +1,4 @@
-from ArquivosPy import ScreenPrints
+from FilePy import ScreenPrints
 
 
 def check_board_number(user_choice: int) -> None:
Index: FilePy/Inputs/MainMenu/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy import ScreenPrints, Game\r\n\r\n\r\ndef open_option(user_choice_option: int) -> None:\r\n    OPTION_ONE: int = 1\r\n\r\n    if user_choice_option == OPTION_ONE:\r\n        Game.inicialize()\r\n    else:\r\n        pass\r\n\r\n\r\ndef is_exit_option(user_choice: int) -> bool:\r\n    OPTION_EXIT: int = 3\r\n\r\n    if user_choice != OPTION_EXIT:\r\n        return False\r\n\r\n    return True\r\n\r\n\r\ndef check_option_main_menu(user_choice: int) -> None:\r\n    set_option: set[int] = {1, 2, 3}\r\n\r\n    if user_choice not in set_option:\r\n        raise RuntimeError(\"OPÇÃO INVALIDA\")\r\n\r\n\r\ndef is_a_valid_main_menu_option(user_choice: int) -> bool:\r\n\r\n    try:\r\n        check_option_main_menu(user_choice)\r\n        return True\r\n    except RuntimeError as error:\r\n        ScreenPrints.get_report_error(error.__str__())\r\n        return False\r\n\r\n\r\ndef display_options() -> None:\r\n    ScreenPrints.get_display_option(\"BLUE\", \"1\", \"NOVO JOGO\")\r\n    ScreenPrints.get_display_option(\"WHITER\", \"2\", \"TUTORIAL DO JOGO\")\r\n    ScreenPrints.get_display_option(\"BLUE\", \"3\", \"FECHA JOGO\")\r\n\r\n\r\ndef display_main_menu() -> None:\r\n    ScreenPrints.display_header('MENU PRINCIPAL')\r\n    display_options()\r\n    ScreenPrints.get_baseboard()\r\n    print(\" \" * 50, end=\"* \")\r\n\r\n\r\ndef input_main_menu_option() -> int:\r\n    try:\r\n        display_main_menu()\r\n        user_choice: int = int(input(\"INFORME QUAL A OPÇÃO DESEJADA: \"))\r\n        ScreenPrints.get_clear_prompt()\r\n        return user_choice\r\n    except ValueError:\r\n        ScreenPrints.get_clear_prompt()\r\n        return -1\r\n\r\n\r\ndef get_main_manu_entry() -> int:\r\n\r\n    user_choice: int = input_main_menu_option()\r\n\r\n    while not is_a_valid_main_menu_option(user_choice):\r\n        user_choice = input_main_menu_option()\r\n\r\n    return user_choice\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Inputs/MainMenu/__init__.py b/FilePy/Inputs/MainMenu/__init__.py
--- a/FilePy/Inputs/MainMenu/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Inputs/MainMenu/__init__.py	(date 1696698082471)
@@ -1,4 +1,4 @@
-from ArquivosPy import ScreenPrints, Game
+from FilePy import ScreenPrints, Game
 
 
 def open_option(user_choice_option: int) -> None:
Index: FilePy/Inputs/PlayerMovement/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy import ScreenPrints\r\nfrom ArquivosPy.HiddenSums import HiddenSums\r\n\r\n\r\ndef check_coordinate(coordinates: str, hiddenSums: HiddenSums) -> None:\r\n    dict_coord = {\"EASY\": {\"C0\", \"C1\", \"C2\", \"L0\", \"L1\", \"L2\"},\r\n                  \"AVERAGE\": {\"C0\", \"C1\", \"C2\", \"C3\", \"L0\", \"L1\", \"L2\", \"L3\"},\r\n                  \"DIFFICULT\": {\"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"L0\", \"L1\", \"L2\", \"L3\", \"L4\"}\r\n                  }\r\n    if coordinates not in dict_coord[hiddenSums.get_level()]:\r\n        raise RuntimeError(\"A coordenada informada não faz parte do tabuleiro\")\r\n    elif hiddenSums.is_coordinate_complete((coordinates, 0)):\r\n        raise RuntimeError(\"A coordenada informada já etá completa\")\r\n\r\n\r\ndef is_valid_coordinates(coordinates: str, hiddenSums: HiddenSums) -> bool:\r\n    try:\r\n        check_coordinate(coordinates, hiddenSums)\r\n        return True\r\n    except RuntimeError as error:\r\n        ScreenPrints.get_report_error(error.__str__())\r\n        return False\r\n\r\n\r\ndef check_guess(hiddenSums: HiddenSums, guess: int) -> None:\r\n    dict_limit_min: dict[str, int] = {\"EASY\": 6, \"AVERAGE\": 10, \"DIFFICULT\": 15}\r\n    dict_limit_max: dict[str, int] = {\"EASY\": 87, \"AVERAGE\": 234, \"DIFFICULT\": 490}\r\n\r\n    if dict_limit_min[hiddenSums.get_level()] > guess or guess > dict_limit_max[hiddenSums.get_level()]:\r\n        raise RuntimeError(f\"O palpite está fora no limite, seu palpite deve está entre \"\r\n                           f\"{dict_limit_min[hiddenSums.get_level()]} até {dict_limit_max[hiddenSums.get_level()]}\")\r\n\r\n\r\ndef is_valid_guess(hiddenSums: HiddenSums, guess: int) -> bool:\r\n    try:\r\n        check_guess(hiddenSums, guess)\r\n        return True\r\n    except RuntimeError as error:\r\n        ScreenPrints.get_report_error(error.__str__())\r\n        return False\r\n\r\n\r\ndef display(hiddenSums: HiddenSums) -> None:\r\n    ScreenPrints.display_header(f\"TABULEIRO {hiddenSums.get_current_player().get_name().upper()}\")\r\n    print()\r\n    print((\"MODO DE JOGO: \" + ScreenPrints.get_paint_color(\"BLUE\")\r\n           + hiddenSums.get_level()\r\n           + ScreenPrints.get_paint_color()).center(125))\r\n    print((\"STATUS: \" + ScreenPrints.get_paint_color(\"YELLOW\")\r\n           + \" \" * 5 + f\"{hiddenSums.get_player_one().get_name()}: |{hiddenSums.get_player_one().get_punctuation():^5}|\"\r\n           + ScreenPrints.get_paint_color()\r\n           + ScreenPrints.get_paint_color(\"RED\")\r\n           + \" \" * 5 + f\"{hiddenSums.get_player_two().get_name()}: |{hiddenSums.get_player_two().get_punctuation():^5}|\"\r\n           + ScreenPrints.get_paint_color()\r\n           + \" \" * 5 + f\"Rodada: |{hiddenSums.get_current_round() :^5}|\").center(200))\r\n\r\n    print()\r\n    ScreenPrints.display_array(hiddenSums)\r\n    ScreenPrints.display_history(hiddenSums)\r\n    print()\r\n    print((\"-=\" * 40).center(170))\r\n    print(\" \" * 50, end=\"* \")\r\n\r\n\r\ndef input_coordinates(hiddenSums: HiddenSums) -> str:\r\n    display(hiddenSums)\r\n    coordinates: str = input(\"INFORME A COORDENADA DESEJADA: \").upper()\r\n\r\n    return coordinates\r\n\r\n\r\ndef input_guess() -> int:\r\n    try:\r\n        print(\" \" * 50, end=\"* \")\r\n        guess: int = int(input(\"INFORME O PALPITE DESEJADO: \"))\r\n        ScreenPrints.get_clear_prompt()\r\n        return guess\r\n    except ValueError:\r\n        ScreenPrints.get_clear_prompt()\r\n        return -1\r\n\r\n\r\ndef inicialize(hiddenSums: HiddenSums) -> tuple[str, int]:\r\n    coordinates: str = input_coordinates(hiddenSums)\r\n    guess: int = input_guess()\r\n\r\n    while not (is_valid_coordinates(coordinates, hiddenSums) and is_valid_guess(hiddenSums, guess)):\r\n        coordinates: str = input_coordinates(hiddenSums)\r\n        guess: int = input_guess()\r\n\r\n    return coordinates, guess\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Inputs/PlayerMovement/__init__.py b/FilePy/Inputs/PlayerMovement/__init__.py
--- a/FilePy/Inputs/PlayerMovement/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Inputs/PlayerMovement/__init__.py	(date 1696698082447)
@@ -1,5 +1,5 @@
-from ArquivosPy import ScreenPrints
-from ArquivosPy.HiddenSums import HiddenSums
+from FilePy import ScreenPrints
+from FilePy.HiddenSums import HiddenSums
 
 
 def check_coordinate(coordinates: str, hiddenSums: HiddenSums) -> None:
Index: FilePy/ScreenPrints/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\n\r\nfrom ArquivosPy.HiddenSums import HiddenSums\r\nfrom ArquivosPy.RevealedElement import RevealedElement\r\n\r\n\r\ndef get_report_error(text: str) -> None:\r\n    SIZE_CENTER_TEXT: int = 170\r\n    NUM_BAR: int = 40\r\n\r\n    print(get_paint_color(\"RED\"), ('=-' * NUM_BAR).center(SIZE_CENTER_TEXT))\r\n    print(\"ERRO!!!\".center(SIZE_CENTER_TEXT + 1))\r\n    print(text.center(SIZE_CENTER_TEXT))\r\n    print(('=-' * NUM_BAR).center(SIZE_CENTER_TEXT + 3), get_paint_color())\r\n\r\n\r\ndef get_clear_prompt() -> None:\r\n    if os.name == 'nt':\r\n        os.system('cls') or None\r\n    else:\r\n        os.system('clear') or None\r\n\r\n\r\ndef display_sub_title(text: str) -> None:\r\n    SIZE_CENTER_TEXT: int = 170\r\n    NUM_BAR: int = 40\r\n\r\n    print(get_paint_color(\"BLUE\"))\r\n    print((\"=-\" * NUM_BAR).center(SIZE_CENTER_TEXT + 2, \" \"))\r\n    print(text.center(SIZE_CENTER_TEXT - 4))\r\n    print((\"=-\" * NUM_BAR).center(SIZE_CENTER_TEXT + 2, \" \"))\r\n    print(get_paint_color())\r\n\r\n\r\ndef display_header(text: str) -> None:\r\n    SIZE_CENTER_TEXT: int = 170\r\n\r\n    display_sub_title(\"SOMAS ESCONDIDAS\")\r\n\r\n    print((\"= \" * 23).center(SIZE_CENTER_TEXT - 2, \" \"))\r\n    print(((\"==\" * 10) + get_paint_color(\"BLUE\") + \" \" + text + \" \"\r\n           + get_paint_color() + (\"==\" * 10)).center(SIZE_CENTER_TEXT + 11))\r\n    print((\"= \" * 20).center(SIZE_CENTER_TEXT, \" \"))\r\n    print((\"= \" * 15).center(SIZE_CENTER_TEXT, \" \"))\r\n    print((\"= \" * 5).center(SIZE_CENTER_TEXT, \" \"))\r\n    print((\"= \" * 3).center(SIZE_CENTER_TEXT, \" \"))\r\n\r\n\r\ndef get_baseboard() -> None:\r\n    SIZE_CENTER: int = 170\r\n\r\n    print(\"\\n\")\r\n    print((\"-=\" * 40).center(SIZE_CENTER))\r\n\r\n\r\ndef get_paint_color(color: str = \"WHITE\") -> str:\r\n    dict_color: dict[str, str] = {\"RED\": \"\\033[1;31m\", \"BLUE\": \"\\033[1;34m\", \"YELLOW\": \"\\033[1;33m\",\r\n                                  \"GREEN\": \"\\033[1;32m\"}\r\n    if color in dict_color:\r\n        return dict_color[color]\r\n\r\n    return \"\\033[1;97m\"\r\n\r\n\r\ndef get_display_option(color: str, num_option: str, name_option: str) -> None:\r\n    SIZE_CENTER_TEXT: int = 170\r\n\r\n    print(get_paint_color(color))\r\n    print(\"\\n\", f\"[ {num_option} ] — {name_option}\".center(SIZE_CENTER_TEXT))\r\n    print(get_paint_color())\r\n\r\n\r\ndef display_array(hiddenSums: HiddenSums) -> None:\r\n    dict_column_coordinates: dict[str, list[str]] = {\"EASY\": [\" \", \"C0\", \"C1\", \"C2\", \"SOMA\"],\r\n                                                     \"AVERAGE\": [\" \", \"C0\", \"C1\", \"C2\", \"C3\", \"SOMA\"],\r\n                                                     \"DIFFICULT\": [\" \", \"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"SOMA\"]\r\n                                                     }\r\n    dict_line_coordinates: dict[str, list[str]] = {\"EASY\": [\"L0\", \"L1\", \"L2\", \"SOMA\"],\r\n                                                   \"AVERAGE\": [\"L0\", \"L1\", \"L2\", \"L3\", \"SOMA\"],\r\n                                                   \"DIFFICULT\": [\"L0\", \"L1\", \"L2\", \"L3\", \"L4\", \"SOMA\"]\r\n                                                   }\r\n    dict_range: dict[str, int] = {\"EASY\": 3, \"AVERAGE\": 4, \"DIFFICULT\": 5}\r\n    dict_print: dict[str, int] = {\"EASY\": 225, \"AVERAGE\": 240, \"DIFFICULT\": 254}\r\n\r\n    line = 0\r\n    SIZE_CENTER: int = 170\r\n\r\n    print((\"|T\" + \"======T\" * len(dict_column_coordinates[hiddenSums.get_level()]) + \"|\").center(SIZE_CENTER))\r\n    print((\"|\" + \"------|\" * len(dict_column_coordinates[hiddenSums.get_level()])).center(SIZE_CENTER))\r\n\r\n    string: str = \"|\"\r\n    for i in dict_column_coordinates[hiddenSums.get_level()]:\r\n        string += f'{i:^6}'\"|\"\r\n    print(string.center(SIZE_CENTER))\r\n\r\n    print((\"|\" + \"------|\" * len(dict_column_coordinates[hiddenSums.get_level()])).center(SIZE_CENTER))\r\n\r\n    for i in dict_line_coordinates[hiddenSums.get_level()]:\r\n        string = \"\"\r\n        string += f\"|{i:^6}|\"\r\n        for column in range(dict_range[hiddenSums.get_level()] + 1):\r\n            array: list[list[RevealedElement]] = hiddenSums.get_current_player().get_board().get_revealed_int_array()\r\n\r\n            string += f'{array[line][column].get_str():^20}' + \"|\"\r\n        line += 1\r\n\r\n        print(string.center(dict_print[hiddenSums.get_level()]))\r\n        print((\"|\" + \"------|\" * len(dict_column_coordinates[hiddenSums.get_level()])).center(SIZE_CENTER))\r\n\r\n    print((\"|T\" + \"======T\" * len(dict_column_coordinates[hiddenSums.get_level()]) + \"|\").center(SIZE_CENTER))\r\n\r\n\r\ndef display_history(hiddenSums: HiddenSums) -> None:\r\n    STR_GUESS_MAX: str = \"PALPITES MAIORES:\"\r\n    list_max: list[tuple[str, int, str]] = join_list(hiddenSums.get_player_one().get_history_guess_max(),\r\n                                                     hiddenSums.get_player_two().get_history_guess_max())\r\n    STR_GUESS_MIN: str = \"PALPITES MENORES:\"\r\n    list_min: list[tuple[str, int, str]] = join_list(hiddenSums.get_player_one().get_history_guess_min(),\r\n                                                     hiddenSums.get_player_two().get_history_guess_min())\r\n    STR_GUESS_EGUAIS: str = \"PALPITES IGUAIS:\"\r\n    list_eguais: list[tuple[str, int, str]] = join_list(hiddenSums.get_player_one().get_history_guess_eguais(),\r\n                                                        hiddenSums.get_player_two().get_history_guess_eguais())\r\n\r\n    print()\r\n    list_history(STR_GUESS_MIN, list_min)\r\n    list_history(STR_GUESS_MAX, list_max)\r\n    list_history(STR_GUESS_EGUAIS, list_eguais)\r\n\r\n\r\ndef join_list(list1: list[tuple[str, int, str]], list2: [tuple[str, int, str]]):\r\n    n1 = len(list1)\r\n    n2 = len(list2)\r\n    list_final = []\r\n    tam_max = max(n1, n2)\r\n\r\n    for i in range(tam_max):\r\n        if i < n1:\r\n            list_final.append(list1[i])\r\n        if i < n2:\r\n            list_final.append(list2[i])\r\n\r\n    return list_final\r\n\r\n\r\ndef list_history(string: str, list_h: [tuple[str, int, str]]) -> None:\r\n    string += \" \"\r\n    PAINT_WHITE: str = \"\\033[1;97m\"\r\n    for i in range(len(list_h)):\r\n        string += f\"|{list_h[i][2]}{list_h[i][0]} : {list_h[i][1]}{PAINT_WHITE}| \"\r\n\r\n    print(\" \" * 46, end=\"\")\r\n    print(string)\r\n\r\n\r\ndef display_winner(hiddenSums: HiddenSums) -> None:\r\n    display_header(hiddenSums.decide_winner())\r\n    print()\r\n    print((\"MODO DE JOGO: \" + get_paint_color(\"BLUE\")\r\n           + hiddenSums.get_level()\r\n           + get_paint_color()).center(125))\r\n    print((\"STATUS: \" + get_paint_color(\"YELLOW\")\r\n           + \" \" * 5 + f\"{hiddenSums.get_player_one().get_name()}: |{hiddenSums.get_player_one().get_punctuation():^5}|\"\r\n           + get_paint_color()\r\n           + get_paint_color(\"RED\")\r\n           + \" \" * 5 + f\"{hiddenSums.get_player_two().get_name()}: |{hiddenSums.get_player_two().get_punctuation():^5}|\"\r\n           + get_paint_color()\r\n           + \" \" * 5 + f\"Rodada: |{hiddenSums.get_current_round() :^5}|\").center(200))\r\n    display_array(hiddenSums)\r\n    display_history(hiddenSums)\r\n    get_baseboard()\r\n\r\n    input(\" Pressione [ENTER] para retorna para o menu principal \".center(170, \"-\"))\r\n    get_clear_prompt()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/ScreenPrints/__init__.py b/FilePy/ScreenPrints/__init__.py
--- a/FilePy/ScreenPrints/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/ScreenPrints/__init__.py	(date 1696698082346)
@@ -1,7 +1,7 @@
 import os
 
-from ArquivosPy.HiddenSums import HiddenSums
-from ArquivosPy.RevealedElement import RevealedElement
+from FilePy.HiddenSums import HiddenSums
+from FilePy.RevealedElement import RevealedElement
 
 
 def get_report_error(text: str) -> None:
Index: FilePy/Player/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ArquivosPy.Board import Board\r\nfrom ArquivosPy.RevealedElement import RevealedElement\r\n\r\n\r\nclass Player:\r\n    def __init__(self, name: str, board: Board, color: str) -> None:\r\n        self.__name_gamer__: str = name\r\n        self.__board__: Board = board\r\n        self.__punctuation__: int = 0\r\n        self.__color__: str = color\r\n\r\n        self.__current_guess__: tuple[str, int] = tuple()\r\n        self.__bigger_guess_list__: list[tuple[str, int, str]] = []\r\n        self.__minor_guess_list__: list[tuple[str, int, str]] = []\r\n        self.__equal_guess_list__: list[tuple[str, int, str]] = []\r\n\r\n    def set_current_guess(self, current_guess: tuple[str, int]) -> None:\r\n        self.__current_guess__ = current_guess\r\n\r\n    def add_history(self):\r\n        coord, number = self.__current_guess__\r\n        guess: tuple[str, int, str] = (coord, number, self.__color__)\r\n\r\n        if self.is_max():\r\n            self.__bigger_guess_list__.append(guess)\r\n        elif self.is_min():\r\n            self.__minor_guess_list__.append(guess)\r\n        else:\r\n            self.__equal_guess_list__.append(guess)\r\n\r\n    def count_points(self) -> None:\r\n        RIGHT_GUESS: int = 0\r\n\r\n        if self.get_difference_of_guess_to_sum() == RIGHT_GUESS:\r\n            self.__punctuation__ += self.__board__.count_revealed_houses(self.__current_guess__)\r\n        elif not self.__board__.is_coordinate_complete(self.__current_guess__):\r\n            self.__punctuation__ += 1\r\n\r\n    def get_difference_of_guess_to_sum(self) -> int:\r\n        if self.__current_guess__[1] < self.__board__.get_sum_of_coordinate(self.__current_guess__):\r\n            return self.__board__.get_sum_of_coordinate(self.__current_guess__) - self.__current_guess__[1]\r\n\r\n        return self.__current_guess__[1] - self.__board__.get_sum_of_coordinate(self.__current_guess__)\r\n\r\n    def reveal_house(self) -> list[RevealedElement]:\r\n        if self.is_max() and not self.__board__.is_coordinate_complete(self.__current_guess__):\r\n            return self.__board__.get_reveal_max(self.__current_guess__, self.__color__)\r\n\r\n        elif self.is_min() and not self.__board__.is_coordinate_complete(self.__current_guess__):\r\n            return self.__board__.get_reveal_min(self.__current_guess__, self.__color__)\r\n\r\n        elif not self.__board__.is_coordinate_complete(self.__current_guess__):\r\n            return self.__board__.get_reveal_all(self.__current_guess__, self.__color__)\r\n\r\n        return []\r\n\r\n    def is_max(self):\r\n        if self.__current_guess__[1] <= self.__board__.get_sum_of_coordinate(self.__current_guess__):\r\n            return False\r\n        return True\r\n\r\n    def is_min(self):\r\n        if self.__current_guess__[1] >= self.__board__.get_sum_of_coordinate(self.__current_guess__):\r\n            return False\r\n        return True\r\n\r\n    def get_board(self) -> Board:\r\n        return self.__board__\r\n\r\n    def get_name(self) -> str:\r\n        return self.__name_gamer__\r\n\r\n    def get_punctuation(self) -> int:\r\n        return self.__punctuation__\r\n\r\n    def get_history_guess_max(self) -> list[tuple[str, int, str]]:\r\n        return self.__bigger_guess_list__\r\n\r\n    def get_history_guess_min(self) -> list[tuple[str, int, str]]:\r\n        return self.__minor_guess_list__\r\n\r\n    def get_history_guess_eguais(self) -> list[tuple[str, int, str]]:\r\n        return self.__equal_guess_list__\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FilePy/Player/__init__.py b/FilePy/Player/__init__.py
--- a/FilePy/Player/__init__.py	(revision 4241595d4dcf76adf735d0b4e7c7d61179bbe589)
+++ b/FilePy/Player/__init__.py	(date 1696698082546)
@@ -1,5 +1,5 @@
-from ArquivosPy.Board import Board
-from ArquivosPy.RevealedElement import RevealedElement
+from FilePy.Board import Board
+from FilePy.RevealedElement import RevealedElement
 
 
 class Player:
